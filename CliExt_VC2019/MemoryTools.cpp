#include "StdAfx.h"
#include "MemoryTools.h"
#include "NetworkHandler.h"
#include "HWID.h"
#include <algorithm>
#include <iterator>

CMemoryTools g_MemoryTools;

LPBYTE CMemoryTools::FindMemory(LPBYTE lpMemory, UINT memorySize, LPBYTE lpData, UINT dataSize, bool& invalid)
{
	////VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
	bool found = false;
	try
	{
		UINT correctData = 0;
		for(UINT n=0;n<memorySize;n++)
		{
			if(lpMemory[n] == lpData[correctData])
			{
				correctData++;
			}else
			{
				correctData = 0;
			}
			if(correctData == dataSize)
			{
				return &lpMemory[n-dataSize];
			}
		}
	}catch(...)
	{
		invalid = true;
	}
	////VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;
	return 0;
};

bool CMemoryTools::FindMemoryEnc2(LPBYTE lpMemory, UINT memorySize, LPBYTE lpData, UINT dataSize, bool& invalid)
{
	////VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
	bool found = false;
	try
	{
		UINT correctData = 0;
		for(UINT n=0;n<memorySize;n++)
		{
			BYTE iCheckBYTE = lpData[correctData] ^ g_MemoryTools.GetIt(correctData);

			if(lpMemory[n] == iCheckBYTE)
			{
				correctData++;
			}else
			{
				correctData = 0;
			}
			if(correctData == dataSize)
			{
				//return &lpMemory[n-dataSize];
				return true;
			}
		}
	}catch(...)
	{
		invalid = true;
	}
	////VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;
	return false;
};

bool CMemoryTools::FindMemory(vector<char> lpMemory, UINT memorySize, LPBYTE lpData, UINT dataSize)
{
	////VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;

	bool found = false;
	try
	{
		UINT correctData = 0;
		for(UINT n=0;n<memorySize;n++)
		{
			if(lpMemory[n] == lpData[correctData])
			{
				correctData++;
			}else
			{
				correctData = 0;
			}
			if(correctData == dataSize)
			{
				//return (LPBYTE)0x01;
				found = true;
			}
		}
	}catch(...)
	{
		//invalid = false;
	}

	////VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;
	return found;
};

bool CMemoryTools::FindMemory(vector<BYTE> lpMemory, UINT memorySize, LPBYTE lpData, UINT dataSize)
{
	////VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;

	bool found = false;
	try
	{
		UINT correctData = 0;
		for(UINT n=0;n<memorySize;n++)
		{
			if(lpMemory[n] == lpData[correctData])
			{
				correctData++;
			}else
			{
				correctData = 0;
			}
			if(correctData == dataSize)
			{
				//return (LPBYTE)0x01;
				found = true;
			}
		}
	}catch(...)
	{
		//invalid = false;
	}

	////VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;
	return found;
};

bool CMemoryTools::FindMemoryEnc(vector<BYTE> lpMemory, LPBYTE lpData, UINT dataSize  )
{
	////VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;

	bool found = false;
	try
	{
		UINT correctData = 0;
		for( UINT n=0; n<lpMemory.size(); n++ )
		{
			if(dataSize>0 && found == false)
			{
				BYTE iCheckBYTE = lpData[correctData] ^ GetIt(correctData);

				if(lpMemory[n] == iCheckBYTE)
					correctData++;	
				else
					correctData = 0;

				if(correctData == dataSize)
					found = true;
			}
		}
	}catch(...)
	{

	}

	////VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;
	return found;
};

//int CMemoryTools::FindMemory3(vector<char> lpMemory, UINT memorySize, vector<char> lpData,  vector<char> lpData2,  vector<char> lpData3,  vector<char> lpData4, vector<char> lpData5, UINT dataSize, UINT dataSize2, UINT dataSize3, UINT dataSize4, UINT dataSize5)
vector<BOOL> CMemoryTools::FindMemoryEnc2(vector<BYTE> lpMemory, vector<BYTE> lpData, vector<BYTE> lpData2, vector<BYTE> lpData3, vector<BYTE> lpData4, vector<BYTE> lpData5, vector<BYTE> lpData6, vector<BYTE> lpData7, vector<BYTE> lpData8, vector<BYTE> lpData9, vector<BYTE> lpData10 )
{

	bool found = false;
	int done = 0;
	//bool Result[4];/* = { 0, 0, 0, 0, 0 };*/
	vector<BOOL> Result;

	Result.push_back(0); Result.push_back(0); Result.push_back(0); Result.push_back(0); Result.push_back(0);
	Result.push_back(0); Result.push_back(0); Result.push_back(0); Result.push_back(0); Result.push_back(0);
	try
	{
		UINT correctData = 0;
		UINT correctData2 = 0;
		UINT correctData3 = 0;
		UINT correctData4 = 0;
		UINT correctData5 = 0;

		UINT correctData6 = 0;
		UINT correctData7 = 0;
		UINT correctData8 = 0;
		UINT correctData9 = 0;
		UINT correctData10 = 0;
		//UINT falseData = 0;
		for(UINT n=0;n<lpMemory.size();n++)
		{
			if(lpData.size()>0 && Result[0] == 0)
			{
				//MessageBox(NULL, L"Here" , L"Antibot!", MB_OK);
				/*//VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
				static const BYTE xorKey[256] = { 0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde };
				BYTE iCheckBYTE = lpData[correctData] ^ xorKey[correctData];
				//VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;*/
				
				BYTE iCheckBYTE = lpData[correctData] ^ GetIt(correctData);

				if(lpMemory[n] == iCheckBYTE)
					correctData++;	
				else
					correctData = 0;

				if(correctData == lpData.size())
				{
					Result[0] = 1;
					//MessageBox(NULL, L"Found1" , L"Antibot!", MB_OK);
				}
			}

			if(lpData2.size()>0 && Result[1] == 0)
			{
				/*//VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
				static const BYTE xorKey[256] = { 0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde };
				BYTE iCheckBYTE2 = lpData2[correctData2] ^ xorKey[correctData2];
				//VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;*/
				
				BYTE iCheckBYTE2 = lpData2[correctData2] ^ GetIt(correctData2);

				if(lpMemory[n] == iCheckBYTE2)
					correctData2++;	
				else
					correctData2 = 0;

				if(correctData2 == lpData2.size())
				{
					Result[1] = 1;
					//MessageBox(NULL, L"Found2" , L"Antibot!", MB_OK);
				}
			}

			if(lpData3.size()>0 && Result[2] == 0)
			{
				/*//VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
				static const BYTE xorKey[256] = { 0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde };
				BYTE iCheckBYTE3 = lpData3[correctData3] ^ xorKey[correctData3];
				//VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;*/
				
				BYTE iCheckBYTE3 = lpData3[correctData3] ^ GetIt(correctData3);

				if(lpMemory[n] == iCheckBYTE3)
					correctData3++;	
				else
					correctData3 = 0;
			
				if(correctData3 == lpData3.size())
				{
					Result[2] = 1;
					//MessageBox(NULL, L"Found3" , L"Antibot!", MB_OK);
				}
			}

			if(lpData4.size()>0 && Result[3] == 0)
			{
				/*//VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
				static const BYTE xorKey[256] = { 0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde };
				BYTE iCheckBYTE4 = lpData4[correctData4] ^ xorKey[correctData4];
				//VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;*/
				
				BYTE iCheckBYTE4 = lpData4[correctData4] ^ GetIt(correctData4);

				if(lpMemory[n] == iCheckBYTE4)
					correctData4++;	
				else
					correctData4 = 0;

				if(correctData4 == lpData4.size())
				{
					Result[3] = 1;
					//MessageBox(NULL, L"Found4" , L"Antibot!", MB_OK);
				}
			}
			if(lpData5.size()>0 && Result[4] == 0)
			{
				/*//VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
				static const BYTE xorKey[256] = { 0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde };
				BYTE iCheckBYTE5 = lpData5[correctData5] ^ xorKey[correctData5];
				//VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;*/
				
				BYTE iCheckBYTE5 = lpData5[correctData5] ^ GetIt(correctData5);

				if(lpMemory[n] == iCheckBYTE5)
					correctData5++;	
				else
					correctData5 = 0;

				if(correctData5 == lpData5.size())
				{
					Result[4] = 1;
					//MessageBox(NULL, L"Found5" , L"Antibot!", MB_OK);
				}
			}

			if(lpData6.size()>0 && Result[5] == 0)
			{
				BYTE iCheckBYTE6 = lpData6[correctData6] ^ GetIt(correctData6);

				if(lpMemory[n] == iCheckBYTE6)
					correctData6++;	
				else
					correctData6 = 0;

				if(correctData6 == lpData6.size())
				{
					//MessageBox(NULL, L"Found6" , L"Antibot!", MB_OK);
					Result[5] = 1;
				}
			}
			if(lpData7.size()>0 && Result[6] == 0)
			{
				BYTE iCheckBYTE5 = lpData7[correctData7] ^ GetIt(correctData7);

				if(lpMemory[n] == iCheckBYTE5)
					correctData7++;	
				else
					correctData7 = 0;

				if(correctData7 == lpData7.size())
				{
					//MessageBox(NULL, L"Found7" , L"Antibot!", MB_OK);
					Result[6] = 1;
					
				}
			}
			if(lpData8.size()>0 && Result[7] == 0)
			{
				BYTE iCheckBYTE5 = lpData8[correctData8] ^ GetIt(correctData8);

				if(lpMemory[n] == iCheckBYTE5)
					correctData8++;	
				else
					correctData8 = 0;

				if(correctData8 == lpData8.size())
				{
					//MessageBox(NULL, L"Found8" , L"Antibot!", MB_OK);
					Result[7] = 1;
				}
			}
			if(lpData9.size()>0 && Result[8] == 0)
			{
				BYTE iCheckBYTE5 = lpData9[correctData9] ^ GetIt(correctData9);

				if(lpMemory[n] == iCheckBYTE5)
					correctData9++;	
				else
					correctData9 = 0;

				if(correctData9 == lpData9.size())
				{
					//MessageBox(NULL, L"Found9" , L"Antibot!", MB_OK);
					Result[8] = 1;
				}
			}
			if(lpData10.size()>0 && Result[9] == 0)
			{
				BYTE iCheckBYTE5 = lpData10[correctData10] ^ GetIt(correctData10);

				if(lpMemory[n] == iCheckBYTE5)
					correctData10++;	
				else
					correctData10 = 0;

				if(correctData10 == lpData10.size())
				{
					//MessageBox(NULL, L"Found10" , L"Antibot!", MB_OK);
					Result[9] = 1;
				}
			}
		}
	}catch(...)
	{
	}

	return Result;
};

BYTE CMemoryTools::GetIt(UINT pos)
{
	
	BYTE ReturnValue = 0x00;

	if( pos == 0 )
		ReturnValue = 0x32;
	else if( pos == 1 )
		ReturnValue = 0x9d;
	else if( pos == 2 )
		ReturnValue = 0x12;
	else
	{
//VM_TIGER_RED_START; //dd5		//VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;
		static const BYTE xorKey[256] = { 0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde };
		ReturnValue = xorKey[pos];

//VM_TIGER_RED_END; //dd5		//VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;
	}

	
	return ReturnValue;
}

bool CMemoryTools::IsSameMemory(HANDLE hProcess, PVOID lpStartAddress, LPBYTE lpMemory, UINT size)
{
	//VM_TIGER_RED_START; //dd5	//VM_TIGER_RED_START; //dd5		VIRTUALIZER_START;

	WCHAR wKernel[] = { L'K', L'e', L'r', L'n', L'e', L'l', L'3', L'2', L'.', L'd', L'l', L'l', 0 };
	HMODULE hKernel = GetModuleHandle(wKernel);

	CHAR sReadProcessMemory[] = { 'R', 'e', 'a', 'd', 'P', 'r', 'o', 'c', 'e', 's', 's', 'M', 'e', 'm', 'o', 'r', 'y', 0 };
	typedef BOOL (WINAPI * __ReadProcessMemory)(__in      HANDLE hProcess, __in      LPCVOID lpBaseAddress, __out_bcount_part(nSize, *lpNumberOfBytesRead) LPVOID lpBuffer, __in      SIZE_T nSize, __out_opt SIZE_T * lpNumberOfBytesRead);
	static __ReadProcessMemory _ReadProcessMemory = (__ReadProcessMemory)GetProcAddress(hKernel, sReadProcessMemory);

	bool ret = false;

	SIZE_T readed = 0;
	BYTE buffer[0x10000];
	if(size > 0x10000)
	{
		size = 0x10000;
	}
	try
	{
		if(_ReadProcessMemory(hProcess, lpStartAddress, &buffer, size, &readed))
		{

			if(!memcmp(buffer, lpMemory, size))
			{
				ret = true;
			}
		}
	}catch(...)
	{

	}

	//VM_TIGER_RED_END; //dd5	//VM_TIGER_RED_END; //dd5		VIRTUALIZER_END;
	return ret;
}

int CMemoryTools::CompareMemory(LPBYTE lpDest, LPBYTE lpSource, UINT size)
{
	try
	{
		return memcmp(lpDest, lpSource, size);
	}catch(...)
	{
		return 1;
	}
}

BOOL CMemoryTools::GetAddressOfData(DWORD pid, const char *data, size_t len)
{
	//VM_TIGER_RED_START;

	CHAR sOpenProcess[] = { 'O', 'p', 'e', 'n', 'P', 'r', 'o', 'c', 'e', 's', 's', 0 };
	WCHAR wKernel[] = { L'K', L'e', L'r', L'n', L'e', L'l', L'3', L'2', L'.', L'd', L'l', L'l', 0 };
	HMODULE hKernel = GetModuleHandle(wKernel);

	typedef HANDLE (WINAPI * __OpenProcess) (__in DWORD dwDesiredAccess, __in BOOL bInheritHandle, __in DWORD dwProcessId);
	static __OpenProcess _OpenProcess = (__OpenProcess)GetProcAddress(hKernel, sOpenProcess);

	CHAR sReadProcessMemory[] = { 'R', 'e', 'a', 'd', 'P', 'r', 'o', 'c', 'e', 's', 's', 'M', 'e', 'm', 'o', 'r', 'y', 0 };
	typedef BOOL (WINAPI * __ReadProcessMemory)(__in      HANDLE hProcess, __in      LPCVOID lpBaseAddress, __out_bcount_part(nSize, *lpNumberOfBytesRead) LPVOID lpBuffer, __in      SIZE_T nSize, __out_opt SIZE_T * lpNumberOfBytesRead);
	static __ReadProcessMemory _ReadProcessMemory = (__ReadProcessMemory)GetProcAddress(hKernel, sReadProcessMemory);

	CHAR sVirtualQueryEx[] = { 'V', 'i', 'r', 't', 'u', 'a', 'l', 'Q', 'u', 'e', 'r', 'y', 'E', 'x', 0 };
	typedef SIZE_T (WINAPI * __VirtualQueryEx)(__in     HANDLE hProcess, __in_opt LPCVOID lpAddress, __out_bcount_part(dwLength, return) PMEMORY_BASIC_INFORMATION lpBuffer, __in     SIZE_T dwLength );
	static __VirtualQueryEx _VirtualQueryEx = (__VirtualQueryEx)GetProcAddress(hKernel, sVirtualQueryEx);
	//VM_TIGER_RED_END;

    HANDLE process = _OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid);
    if(process)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);

        MEMORY_BASIC_INFORMATION info;
        std::vector<char> chunk;
        char* p = 0;
        while(p < si.lpMaximumApplicationAddress)
        {
            if(_VirtualQueryEx(process, p, &info, sizeof(info)) == sizeof(info))
            {
                p = (char*)info.BaseAddress;
                chunk.resize(info.RegionSize);
                SIZE_T bytesRead;
                if(_ReadProcessMemory(process, p, &chunk[0], info.RegionSize, &bytesRead))
                {
                    for(size_t i = 0; i < (bytesRead - len); ++i)
                    {
                        if(!memcmp(data, &chunk[i], len) == 0)
                        {
                            return true;
                        }
                    }
                }
                p += info.RegionSize;
            }
        }
    }
    return false;
}

time_t CMemoryTools::FILETIMEtoTIME_T(FILETIME const& ft)
{
	ULARGE_INTEGER ull;
	ull.LowPart = ft.dwLowDateTime;
	ull.HighPart = ft.dwHighDateTime;
	return ull.QuadPart / 10000000ULL - 11644473600ULL;
}

void CMemoryTools::SaveLibrary(PSTR moduleName, PSTR expr)
{
	//	ofstream lib("client.log");
	//	lib << moduleName << endl << expr << endl;
	//	lib.close();
}

string CMemoryTools::ModuleNameExtractor(string name)
{
	size_t lastPos = 0;
	size_t temp = name.find("\\");
	while(temp != string::npos)
	{
		lastPos = temp;
		temp = name.find("\\", lastPos+1);
	}
	if(lastPos > 0 && lastPos < name.size())
	{
		name = name.substr(lastPos+1);
	}
	return name;
}

void CMemoryTools::PrintData()
{
/*	static const BYTE botData1[41] = {
		0x25, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x4D, 0x00, 0x41, 0x00, 0x50, 0x00, 0x53, 0x00, 0x5C, 0x00,
		0x25, 0x00, 0x64, 0x00, 0x5F, 0x00, 0x25, 0x00, 0x64, 0x00, 0x5F, 0x00, 0x25, 0x00, 0x64, 0x00,
		0x2E, 0x00, 0x44, 0x00, 0x41, 0x00, 0x54, 0x00, 0x00
	};

	static const BYTE botData2[77] = {
		0x46, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x50, 0x00, 0x6C, 0x00,
		0x61, 0x00, 0x79, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x25, 0x00, 0x73, 0x00, 0x20, 0x00,
		0x2C, 0x00, 0x20, 0x00, 0x4C, 0x00, 0x6F, 0x00, 0x67, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x74, 0x00,
		0x2C, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x73, 0x00, 0x74, 0x00, 0x61, 0x00, 0x6E, 0x00,
		0x63, 0x00, 0x65, 0x00, 0x20, 0x00, 0x25, 0x00, 0x64, 0x00, 0x2E, 0x00, 0x00
	};

	static const BYTE botData3[54] = {
		0x4C, 0x00, 0x56, 0x00, 0x3A, 0x00, 0x25, 0x00, 0x64, 0x00, 0x0A, 0x00, 0x48, 0x00, 0x50, 0x00,
		0x3A, 0x00, 0x25, 0x00, 0x34, 0x00, 0x64, 0x00, 0x2F, 0x00, 0x25, 0x00, 0x34, 0x00, 0x64, 0x00,
		0x0A, 0x00, 0x4D, 0x00, 0x50, 0x00, 0x3A, 0x00, 0x25, 0x00, 0x34, 0x00, 0x64, 0x00, 0x2F, 0x00,
		0x25, 0x00, 0x34, 0x00, 0x64, 0x00
	};

	static const BYTE botData4[36] = {
		0x5F, 0x00, 0x53, 0x00, 0x48, 0x00, 0x4C, 0x00, 0x32, 0x00, 0x57, 0x00, 0x61, 0x00, 0x6C, 0x00,
		0x6B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x31, 0x00, 0x30, 0x00, 0x2E, 0x00, 0x36, 0x00, 0x2E, 0x00,
		0x30, 0x00, 0x00, 0x00
	};

	static const BYTE botData5[68] = {
		0x2F, 0x63, 0x20, 0x22, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x68, 0x6F,
		0x73, 0x74, 0x20, 0x26, 0x20, 0x64, 0x65, 0x6C, 0x20, 0x64, 0x33, 0x64, 0x39, 0x2E, 0x64, 0x6C,
		0x6C, 0x20, 0x26, 0x20, 0x72, 0x65, 0x6E, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x2E, 0x66, 0x69, 0x6C,
		0x65, 0x20, 0x64, 0x33, 0x64, 0x39, 0x2E, 0x64, 0x6C, 0x6C, 0x20, 0x26, 0x20, 0x6C, 0x32, 0x2E,
		0x65, 0x78, 0x65, 0x20
	};

	static const BYTE botData6[32] = { 0x85, 0xDF, 0x83, 0xC5, 0x04, 0x60, 0x9C, 0x68, 0x17, 0x34, 0x4D, 0x43, 0xFF, 0x74, 0x24, 0x08,
		0x8D, 0x64, 0x24, 0x2C, 0xE9, 0x18, 0x8D, 0xFF, 0xFF, 0xE9, 0xD7, 0x2D, 0x00, 0x00, 0xC7, 0x04 };
	static const BYTE botData7[32] = { 0x52, 0x90, 0x6E, 0x2B, 0x9C, 0x9C, 0x60, 0x90, 0x9C, 0x9C, 0x9C, 0x89, 0x5C, 0x24, 0x30, 0x8A, 0x5C, 0x24, 0x04, 0x5B, 0x5B, 0xF6, 0xD7, 0x8B, 0x5C, 0x24, 0x2C, 0xFF, 0x74, 0x24, 0x04, 0xE9 };

	static const BYTE botData8[27] = { 0x6E, 0x65, 0x65, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4C, 0x32, 0x54, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6F, 0x6C, 0x64 };
	static const BYTE botData9[48] = { 0x41, 0x00, 0x75, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x20, 0x00, 0x50, 0x00, 0x61, 0x00, 0x72, 0x00, 0x74, 0x00, 0x79, 0x00, 0x20, 0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x65, 0x00, 0x20, 0x00, 0x4C, 0x00, 0x65, 0x00, 0x61, 0x00, 0x64, 0x00, 0x65, 0x00, 0x72, 0x00 };
	static const BYTE botData10[40] = { 0x56, 0x00, 0x69, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6F, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x76, 0x00, 0x69, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x45, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x62, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x64, 0x00 };


	static const BYTE xorKey[256] = { 0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde };


	stringstream nameStream;
	nameStream << 1 << ".txt";
	ofstream file(nameStream.str().c_str());
	for(int n=0;n<sizeof(botData1);n++)
	{
		BYTE ReturnValue = botData1[n] ^ xorKey[n];
		file << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file.close();

	stringstream nameStream2;
	nameStream2 << 2 << ".txt";
	ofstream file2(nameStream2.str().c_str());
	for(int n=0;n<sizeof(botData2);n++)
	{
		BYTE ReturnValue = botData2[n] ^ xorKey[n];
		file2 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file2.close();

	stringstream nameStream3;
	nameStream3 << 3 << ".txt";
	ofstream file3(nameStream3.str().c_str());
	for(int n=0;n<sizeof(botData3);n++)
	{
		BYTE ReturnValue = botData3[n] ^ xorKey[n];
		file3 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file3.close();

	stringstream nameStream4;
	nameStream4 << 4 << ".txt";
	ofstream file4(nameStream4.str().c_str());
	for(int n=0;n<sizeof(botData4);n++)
	{
		BYTE ReturnValue = botData4[n] ^ xorKey[n];
		file4 << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file4.close();

	stringstream nameStream5;
	nameStream5 << 5 << ".txt";
	ofstream file5(nameStream5.str().c_str());
	for(int n=0;n<sizeof(botData5);n++)
	{
		BYTE ReturnValue = botData5[n] ^ xorKey[n];
		file5 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file5.close();

	stringstream nameStream6;
	nameStream6 << 6 << ".txt";
	ofstream file6(nameStream6.str().c_str());
	for(int n=0;n<sizeof(botData6);n++)
	{
		BYTE ReturnValue = botData6[n] ^ xorKey[n];
		file6 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file6.close();

	stringstream nameStream7;
	nameStream7 << 7 << ".txt";
	ofstream file7(nameStream7.str().c_str());
	for(int n=0;n<sizeof(botData7);n++)
	{
		BYTE ReturnValue = botData7[n] ^ xorKey[n];
		file7 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file7.close();

	stringstream nameStream8;
	nameStream8 << 8 << ".txt";
	ofstream file8(nameStream8.str().c_str());
	for(int n=0;n<sizeof(botData8);n++)
	{
		BYTE ReturnValue = botData8[n] ^ xorKey[n];
		file8 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file8.close();

	stringstream nameStream9;
	nameStream9 << 9 << ".txt";
	ofstream file9(nameStream9.str().c_str());
	for(int n=0;n<sizeof(botData9);n++)
	{
		BYTE ReturnValue = botData9[n] ^ xorKey[n];
		file9 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file9.close();

	stringstream nameStream10;
	nameStream10 << 10 << ".txt";
	ofstream file10(nameStream10.str().c_str());
	for(int n=0;n<sizeof(botData10);n++)
	{
		BYTE ReturnValue = botData10[n] ^ xorKey[n];
		file10 << "0x" << hex << (UINT)(BYTE)ReturnValue << ", ";
	}
	file10.close();

	*/
}

/*

static const BYTE xorKey[256] = { 
	0x32, 0x9d, 0x12, 0x19, 0xc9, 0x1c, 0x52, 0x93, 
	0x90, 0x8b, 0x8e, 0xc2, 0xc7, 0xd4, 0x0b, 0xe1, 
	0xc8, 0xb5, 0xb1, 0x11, 0xca, 0x3a, 0x0c, 0xb9, 
	0x5d, 0xa8, 0xe0, 0x21, 0x71, 0x8f, 0xdc, 0xe2, 
	0xd4, 0xfc, 0xdf, 0x9b, 0x84, 0x2d, 0x3c, 0xc6, 
	0x08, 0x06, 0x4b, 0xcf, 0x7a, 0x92, 0x15, 0x72, 
	0x83, 0xf5, 0xba, 0x4e, 0xa4, 0xca, 0x53, 0xf4, 
	0x5f, 0xf1, 0x11, 0xe6, 0x5d, 0xe3, 0x69, 0x6c, 
	0xa0, 0xf8, 0x9c, 0xaa, 0x4c, 0x1c, 0xfc, 0xde, 
	0xa5, 0x9a, 0xc2, 0x00, 0x5b, 0x18, 0xf3, 0x0c, 
	0x7c, 0x69, 0x5d, 0x40, 0x0c, 0xca, 0x05, 0xcf, 
	0xf2, 0x99, 0x11, 0x12, 0x80, 0x75, 0x97, 0x79, 
	0xa3, 0x1d, 0x08, 0x19, 0x90, 0x44, 0xea, 0xee, 
	0xe0, 0xbc, 0x76, 0xe3, 0xe8, 0x16, 0xce, 0x85, 
	0x68, 0x31, 0x6f, 0x90, 0x39, 0xd6, 0x85, 0x5b, 
	0x22, 0xcf, 0xd0, 0xf9, 0x86, 0x88, 0xbd, 0x6e, 
	0x06, 0xd6, 0x50, 0x99, 0xb0, 0xd6, 0xab, 0x42, 
	0x25, 0x6a, 0xa4, 0xfb, 0xf3, 0x6a, 0x4c, 0x23, 
	0xc4, 0x17, 0xd5, 0xd4, 0xa5, 0xb8, 0xc0, 0x12, 
	0xb6, 0x10, 0xaf, 0xc8, 0x0a, 0x8e, 0xce, 0x50, 
	0xa1, 0xf3, 0x42, 0xb2, 0x4d, 0x32, 0x6e, 0x85, 
	0x9f, 0x4b, 0x95, 0xa9, 0x8c, 0x1b, 0x9e, 0x8b, 
	0xd8, 0x8c, 0x7e, 0x90, 0x19, 0x5c, 0x2e, 0xd4, 
	0x48, 0xd3, 0x79, 0x58, 0xc0, 0xa1, 0xbf, 0x77, 
	0x9e, 0x38, 0xcb, 0xd5, 0x4d, 0xd3, 0xee, 0xcf, 
	0x50, 0xad, 0x9e, 0x39, 0x11, 0x50, 0x80, 0xd4, 
	0xaf, 0xaa, 0x59, 0x24, 0xa1, 0xd7, 0xc2, 0xf5, 
	0x38, 0x43, 0x07, 0x68, 0xaa, 0x03, 0x13, 0xab, 
	0x22, 0x86, 0x64, 0xed, 0x79, 0x1d, 0xa5, 0x82, 
	0xa2, 0x8c, 0x16, 0xde, 0x24, 0x63, 0x34, 0x71, 
	0x1d, 0x32, 0x64, 0xde, 0x96, 0x6b, 0x0b, 0x21, 
	0x23, 0x83, 0x5e, 0xaa, 0x29, 0xc4, 0xaf, 0xde 
};

*/